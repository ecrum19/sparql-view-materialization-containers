<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>SPARQL Query View Materialization Containers</title>
    <script
      src="https://www.w3.org/Tools/respec/respec-w3c"
      class="remove"
      defer
    ></script>
    <script src="./local-biblio.js" class="remove"></script>
    <script class="remove">
      // All config options at https://respec.org/docs/
      var respecConfig = {
        specStatus: "unofficial",
        editors: [
          { name: "Elias Crum", w3cid: "" },
          { name: "Ruben Taelman", w3cid: "84199" },
        ],
        shortName: "sparql-view-materialization-containers",
        xref: "web-platform",
        canonicalURI: "_ORCHESTRATOR_CURRENT_BUILD_FULL_LINK_",
        previousURI: "_ORCHESTRATOR_PREVIOUS_BUILD_FULL_LINK_",
        logos: [
          {
            src: "logo.png",
            url: "https://knows.idlab.ugent.be/",
            alt: "KNoWS",
            height: 48,
            id: "knows-logo",
          },
        ],
        localBiblio: localBibliography,
      };
    </script>
    <style>
      pre {
        overflow-x: auto;
      }
      code,
      pre {
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas,
          "Liberation Mono", monospace;
      }
      pre.http-example { background: #0b1021; color: #d6e7ff; padding: 1rem; border-radius: .5rem; overflow-x: auto; }
      code.fname { background: #eef; padding: .1rem .35rem; border-radius: .35rem; }
      .note-hint { font-style: italic; opacity: .85; }
    </style>
  </head>
  <body>
    <section id="abstract">
      <p>
        The execution of SPARQL queries, especially over large, federated sources, can be challenging for a number of reasons,
        including performance, availability, and reproducibility.
        To encourage greater reproducibility, sharability, and performance of these queries, a result caching approach offers a pragmatic solution.

        This specification defines <em>SPARQL Query View Materialization Containers</em> (QVMC): 
        HTTP resources that implement the Linked Data Platform (LDP) Container model to store SPARQL query definitions and their corresponding materialized result sets. 
        A QVMC is an <code>ldp:BasicContainer</code> whose members include SPARQL query source files 
        (<code class="fname">*.rq</code>) and SPARQL Results documents (<code class="fname">*.srj</code> for JSON and <code class="fname">*.srx</code> for XML). 
        An RDF index resource named <code class="fname">queries.ttl</code> describes the contained views and how they were generated.
        These guidelines enable clients and tools to reliably leverage cached SPARQL queries, their canonical
        algebra, provenance, and serialized results, in a way that promotes interoperability and reuse.
      </p>
    </section>

    <section id="sotd">
      <p>
        <ul>
          <li>This is an unofficial proposal.</li>
          <li>This is a draft document and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to cite this document as other than a work in progress.</li>
        </ul>
      </p>
    </section>

    <section class="informative">
      <h2>Introduction</h2>
      <p>
        This document discusses the canonical view materialization of SPARQL queries and results. 
        This document is primarily intended for the following audiences:
        <ul>
          <li>Developers of SPARQL clients and tools that wish to leverage standardized materialized queries and results.</li>
          <li>Developers of SPARQL endpoints and services that wish to implement a standardized caching mechanism.</li>
          <li>Researchers and practitioners interested in improving the performance, availability, and reproducibility of SPARQL queries.</li>
        </ul>
      </p>
      <p>
        The goals of this specification are to:
        <ul>
          <li>Define a predictable container layout and naming scheme.</li>
          <li>Specify file formats and media types for query sources and results.</li>
          <li>Define the structure of <code>queries.ttl</code> â€” an RDF index that inventories the views in a container and
          captures provenance.</li>
          <li>Clarify client and server expectations for creating, updating, and retrieving members.</li>
        </ul>
      </p>

      <p>
        To understand the basics in this note ... (knowledge requirements)
        
        The <em>SPARQL Query Cache</em> (SQC) is a conventional layout for
        representing cached SPARQL queries and their results as HTTP resources
        inside an <code>ldp:Container</code>. Each cached query is addressed by
        a stable, opaque identifier derived from a cache key function over the
        query text, dataset/endpoint selection, and selected request headers.
        The cache also stores a canonical SPARQL algebra form and a serialized
        result set for deterministic reuse.
      </p>
    </section>

    <section id="terminology">
      <h2>Terminology</h2>
      <p>Key terms are used as defined in the following specifications: Linked Data Platform (LDP), SPARQL 1.1 Query, SPARQL Results JSON and XML.</p>
      <dl>
        <dt>QVMC</dt>
          <dd>SPARQL Query View Materialization Container (this spec).</dd>
        <dt>Index</dt>
          <dd>The RDF document <code class="fname">queries.ttl</code> at the root of a QVMC.</dd>
      </dl>
      <p class="note-hint">RFC 2119 keywords (MUST, SHOULD, MAY) indicate conformance requirements.</p>
    </section>

    <section id="conformance">
      <p>
        The following prefixes are used throughout the document.
      </p>
      <pre class="query nohighlight">
        PREFIX rdfs: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
        PREFIX prov: &lt;http://www.w3.org/ns/prov#&gt; .
        PREFIX dc: &lt;http://purl.org/dc/terms/&gt; .
        PREFIX sh: &lt;http://www.w3.org/ns/shacl#&gt; .
        PREFIX tq: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-query#&gt; .
        PREFIX tm: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#&gt; .
        PREFIX sd: &lt;http://www.w3.org/ns/sparql-service-description#&gt; .
        PREFIX se: &lt;https://purl.expasy.org/sparql-examples/ontology#&gt; .
        PREFIX qvmc: &lt;https://vocab.example/qvmc#&gt; .
      </pre>
  </section>

  <section id="container-model">
    <h2>Container Model</h2>
    <p>
      A SPARQL query execution, from the perspective of the user, consists of four distinct componenets.
      <ul>
        <li>The SPARQL query algebra (i.e the query itself),</li>
        <li>The target source(s) to which the query, or subsets of the query, is/are submitted and executed,</li>
        <li>The serialized result set obtained from executing the query, and</li>
        <li>The metadata about the query run itself, primarily the date and time of the query.</li>
      </ul>
      This section introduces a materialization approach to record the serialization of each of these components of a SPARQL query execution, which enables the consistent accessing and utilization of these data for users and applications.
    </p>

    <section id="the-container">
      <h3>Resource types</h3>
      <p>
        A QVMC <em>MUST</em> be an HTTP-accessible <code>ldp:BasicContainer</code> and <em>MUST</em> advertise <code>Link: &lt;http://www.w3.org/ns/ldp#BasicContainer&gt; ; rel="type"</code>
        in responses to <code>GET</code> on the container URI. 
        Servers <em>SHOULD</em> also include <code>ldp:contains</code> statements in RDF representations.
      </p>
    </section>

    <section id="members">
      <h3>Members</h3>
      <p>The members of a QVMC are:</p>
      <ul>
        <li>One <strong>index</strong> resource named <code class="fname">queries.ttl</code> (<code>text/turtle</code>).</li>
        <li>Zero or more <strong>SPARQL query files</strong> with extension <code class="fname">.rq</code> and media type <code>application/sparql-query</code>.</li>
        <li>Zero or more <strong>SPARQL result files</strong> with extensions <code class="fname">.srj</code> (<code>application/sparql-results+json</code>) or
        <code class="fname">.srx</code> (<code>application/sparql-results+xml</code>).</li>
      </ul>
      <p>Additional non-normative artifacts (e.g., CSV extracts) MAY be present but are out of scope.</p>
    </section>

    <section id="general-naming-layout">
      <h3>Naming and layout</h3>
      <ul>
        <li>The index <em>MUST</em> be located at <code class="fname">{container}/queries.ttl</code>.</li>
        <li>Implementations <em>SHOULD</em> use a stable <code>{hash}</code> token to bind each query entry to its query SPARQL algebra and results files (details below).</li>
        <li>Query files <em>SHOULD</em> be placed at <code class="fname">{container}/{hash}.rq</code>.</li>
        <li>Result files <em>SHOULD</em> be placed at <code class="fname">{container}/{hash}.{srj|srx}</code>.</li>
      </ul>
      <pre class="http-example" aria-label="Example container layout">
        GET /views/ HTTP/1.1
        Accept: text/turtle
        HTTP/1.1 200 OK
        Link: &lt;http://www.w3.org/ns/ldp#BasicContainer&gt; ; rel="type"
        Content-Type: text/turtle; charset=utf-8

        @prefix ldp: &lt;http://www.w3.org/ns/ldp#&gt; .
        @prefix dc: &lt;http://purl.org/dc/terms/&gt; .
        @prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .

        </views/> a ldp:BasicContainer ;
          dc:title "SPARQL Query Materialization Container" ;
          ldp:contains &lt;/views/queries.ttl&gt; ,
            &lt;/views/hash1.rq&gt; ,
            &lt;/views/hash1.srj&gt; ,
            # ... more members ...
          .
      </pre>
    </section>

    <section id="file-formats">
      <h2>File formats</h2>

      <section id="container-index">
        <h3>Container Index</h3>
        <p>
          The container includes an index file, <code>queries.ttl</code>, which is a Turtle graph that describes each stored SPARQL query entry using terms from <a data-cite="SPARQL11">SPARQL 1.1</a>, <a data-cite="SHACL">SHACL</a>, and <a data-cite="SPARQLSD">Service Description</a>.
        </p>

        <section id="data-model">
          <h3>Data model</h3>
          <p>The following classes and properties are used:</p>
          <ul>
            <li><code>tq:QueryForm</code> â€” a materialized view entry.</li>
            <li><code>dct:title</code>, <code>dct:description</code>, <code>dct:modified</code> â€” human-readable metadata.</li>
            <li><code>tq:QuerySelect</code> â€” the supported SPARQL query operation.</li>
            <li><code>sh:SPARQLExecutable</code> - designates that this hash contains a link to the <code>.rq</code> file.</li>
            <li><code>tq:query</code> (IRI) â€” link to the <code>.rq</code> file.</li>
            <li><code>sh:select</code> (literal) â€” the entry's SPARQL query algebra (identical to that in the entry's .rq file).</li>
            <li><code>tm:result</code> (IRI) â€” link to the <code>.srj</code> or <code>.srx</code> file.</li>
            <li><code>sd:endpoint</code> (IRI) â€” link to the RDF list containing the target sources of the query entry (sources must be valid URIs).</li>
            <li><code>dct:created</code> (xsd:dateTime) â€” timestamp of when the query was executed.</li>
            <li><code>qvmc:status</code> (literal; values: <code>current</code> | <code>stale</code> | <code>failed</code>) â€” indicates the current state of the query entry results.</li>
            <li><code>prov:wasGeneratedBy</code> â€” blank node with provenance information about the query entry.</li>
          </ul>
          <p>
            The index resource itself <em>SHOULD</em> be typed as <code>qvmc:Index</code> and <code>ldp:RDFSource</code> and may carry container-level metadata.
          </p>
        </section>

        <section id="index-shape">
          <h3>Index shape and constraints</h3>

          <p>
            Each <code>tq:QueryForm</code> entry <em>MUST</em> include at least <code>tq:query</code>, <code>tm:result</code>, <code>sd:endpoint</code>, and <code>dct:created</code>. 
            The pair <code>(tq:query, tm:result)</code> <em>MUST</em> be unique within the container. 
            <code>sd:endpoint</code> <em>MUST</em> be a valid RDF list of one or more URIs.
            <code>dct:created</code> <em>MUST</em> be in xsd:dateTime.
            <code>qvmc:status</code> <em>MUST</em> be a literal in the range: <code>current</code> | <code>stale</code> | <code>failed</code>.
            <code>prov:wasGeneratedBy</code> <em>MUST</em> include a <code>prov:Activity</code> with at least <code>prov:used</code> and <code>prov:modified</code>.
          </p>
          <p>
            It is recommended that each <code>tq:QueryForm</code> SPARQL query entry is identified by an opaque, 10-character token 
            (e.g., <code>#aBc1d2Ef3g</code>) composed of integers (0-9) and both lowercase and uppercase letters (a-z, A-Z).
            This <strong>hash</strong> is used as a key to refer to a singular stored SPARQL query entry.
            At a minimum, each <code>tq:QueryForm</code> entry <em>MUST</em> be unique within the <code>queries.ttl</code> file.
          </p>
        </section>

      </section>

      <section>
        <h3>SPARQL query file serialization (<code>.rq</code>)</h3>
        <p>
          Each SPARQL query entry includes a serialization of the SPARQL algebra for the query, stored in a file named <code>{hash}.rq</code>. 
        </p>
        <ul>
          <li><em>MUST</em> be named to match the source query entry's <code>{hash}</code>.</li>
          <li><em>MUST</em> declare media type <code>application/sparql-query</code>.</li>
        </ul>
        <pre id="http-example" aria-label="Example .rq">
          PREFIX : &lt;https://example.org/ontology/&gt;
          SELECT ?s ?score WHERE { ?s :score ?score } ORDER BY DESC(?score) LIMIT 10
        </pre>
      </section>

      <section id="results-serialization">
        <h3>Results file serialization</h3>
        <p>
          Each SPARQL query entry includes a serialization of the results for the query, stored in a file named <code>{hash}.*</code> (where "*" is the descriptive extension of the file-type respresented).
        </p>
        <ul>
          <li><em>MUST</em> be named to match the source query's <code>{hash}</code>.</li>
          <li><em>MUST</em> use either SPARQL Results JSON (<code>application/sparql-results+json</code>) or SPARQL Results XML (<code>application/sparql-results+xml</code>) serialization formats.</li>
        </ul>
      </section>

      <section id="example-queries-ttl">
        <h3>Example - <code>queries.ttl</code></h3>
        <pre class="http-example" aria-label="example queries.ttl">
          @prefix rdfs: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
          @prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .
          @prefix qvmc: &lt;https://vocab.example/qvmc#&gt; .
          @prefix dc: &lt;http://purl.org/dc/terms/&gt; .
          @prefix sh: &lt;http://www.w3.org/ns/shacl#&gt; .
          @prefix tq: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-query#&gt; .
          @prefix tm: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#&gt; .
          @prefix sd: &lt;http://www.w3.org/ns/sparql-service-description#&gt; .
          @prefix se: &lt;https://purl.expasy.org/sparql-examples/ontology#&gt; .
          @base &lt;https://data.example.org/example/&gt; .

          &lt;#index&gt; a qvmc:Index ;
          dc:title "SPARQL Query Materialization Container Example" ;
          dc:modified "2025-09-25T09:00:00Z"^^xsd:dateTime .

          &lt;#aBc1d2Ef3g&gt; a tq:QueryForm, tq:QuerySelect, sh:SPARQLExecutable ;
            dc:title "Top 10 by score" ;
            dc:description "Returns 10 entities with the highest :score." ;
            tq:query &lt;aBc1d2Ef3g.rq&gt; ;
            tm:result &lt;aBc1d2Ef3g.srj&gt; ;
            sh:select "SELECT ?s ?score WHERE { ?s :score ?score } ORDER BY DESC(?score) LIMIT 10" ;
            sd:endpoint &lt;#5926e69f-c619-4029-b516-21affc0598e0&gt; ;
            dc:created "2025-09-24T16:12:03Z"^^xsd:dateTime ;
            qvmc:status "current" ;
            prov:wasGeneratedBy [
              a prov:Activity ;
              prov:used &lt;aBc1d2Ef3g.rq&gt;, &lt;#5926e69f-c619-4029-b516-21affc0598e0&gt; ;
              prov:modified "2025-09-24T16:12:03Z"^^xsd:dateTime
            ] .

          &lt;#5926e69f-c619-4029-b516-21affc0598e0&gt; rdfs:first &lt;https://sparql.example.org/sparql/&gt; ;
            rdfs:rest rdfs:nil .
        </pre>
        The order in which RDF triples occur in an RDF dataset convey no meaning.
      </section>

      <section id="security-privacy">
        <h2>Security &amp; privacy considerations</h2>
        <ul>
          <li>The discussed container and resource structure is designed to be configured with any additional access controls at a user's discretion.</li>
          <li>Consider cache-control headers for implementations where access controls are used and stored data should not be cached by intermediaries.</li>
          <li>Endpoints and dataset IRIs in the index may reveal infrastructure; redact if necessary.</li>
        </ul>
      </section>

      <section id="http-interactions">
        <h3>HTTP interactions</h3>
        <p>
          <strong>Security and Privacy Note:</strong> If access controls are implemented, the following operations are permitted <em>only if authorization is successful</em>:
        </p>
        <ul>
          <li>Implementations <em>MUST</em> expose the container as an <code>ldp:BasicContainer</code> with <code>GET</code> and <code>POST</code>/<code>PUT</code> access rights on all resources for at least one authorized user.</li>
          <li>Implementations MAY support authenticated <code>GET</code> and <code>POST</code>/<code>PUT</code> methods to other authenticated users and/or the public.</li>
        </ul>
      </section>

      <section id="updating-the-index">
        <h3>Updating the index</h3>
        <p>
          Implementations <em>MUST</em> update <code>queries.ttl</code> atomically when new members are added, deleted, or modified. 
          The following describes the requirements for each action:
        </p>
        <ul>
          <li><strong>Add:</strong> 
            When a new query entry is added, create a new <code>tq:QueryForm</code> node with a new unique subject IRI <code>&lt;#${name}&gt;</code>. 
            Both results and query serialization files <em>SHOULD</em> be named <code>&lt;#${name}.rq&gt;</code> and <code>&lt;#${name}.*&gt;</code> respectively after the <code>&lt;#${name}&gt;</code> of the <code>tq:QueryForm</code> node. 
            Set <code>sd:endpoint</code> to an RDF list of one or more source URIs that the query targets. Set <code>dc:created</code> to the creation timestamp.</li>
            ...

          <li><strong>Modify:</strong> 
            For an existing query entry, if the dataset changes or a new execution of the same SPARQL query over the same sources gives different results, update the <code>qvmc:status</code> of the relevant <code>tq:QueryForm</code> node to <code>stale</code>.
            <em>IMPORTANT</em> if the results of the query change, users <em>SHOULD</em> create a new query entry instead of modifying the existing one to preserve provenance.
            In this case, the pre-existing entry's <code>qvmc:status</code> <em>MUST</em> be set to <code>stale</code> and the triple <code>qvmc:linkedQuery</code> <code>&lt;#${updated-entry-name}&gt;</code> <em>MUST</em> be added.
            Whenever a field within an entry is updated, users <em>MUST</em> update <code>prov:wasGeneratedBy</code> with a new timestamp via <code>dc:modified</code>.</li>

          <li><strong>Delete:</strong>
            When a query entry is deleted, remove the corresponding <code>tq:QueryForm</code> node and all references to its associated files (<code>.rq</code>, <code>.srj</code>, <code>.srx</code>) from <code>queries.ttl</code>. Optionally, remove the files themselves from the container.</li>

        </ul>
        <pre class="http-example" aria-label="PATCH example (sparql-update)">
          PATCH /views/queries.ttl HTTP/1.1
          Content-Type: application/sparql-update

          DELETE { &lt;#aBc1d2Ef3g&gt; dct:modified ?t ; qvmc:status ?s }
          INSERT { &lt;#aBc1d2Ef3g&gt; dct:modified "2025-09-25T10:01:22Z"^^xsd:dateTime ; qvmc:status "current" }
          WHERE { OPTIONAL { &lt;#aBc1d2Ef3g&gt; dct:modified ?t ; qvmc:status ?s } }
        </pre>
      </section>

      <!-- <section>
        <h3>Validation (SHACL)</h3>
        <p>Optional SHACL shapes can validate the index. An example is provided:</p>
        <pre class="http-example" aria-label="SHACL for qvmc:View">
          @prefix sh: <http://www.w3.org/ns/shacl#> .
          @prefix qvmc: <https://vocab.example/qvmc#> .
          @prefix dc: <http://purl.org/dc/terms/> .


          qvmc:ViewShape a sh:NodeShape ;
          sh:targetClass qvmc:View ;
          sh:property [ sh:path qvmc:query ; sh:minCount 1 ; sh:nodeKind sh:IRI ] ;
          sh:property [ sh:path qvmc:result ; sh:minCount 1 ; sh:nodeKind sh:IRI ] ;
          sh:property [ sh:path dc:modified ; sh:minCount 1 ] .
        </pre>
      </section> -->
    </section>

    <section id="extensibility">
        <h2>Extensibility</h2>
        <p>
          The index graph MAY include additional metadata such as provenance
          (<code>dct:source</code>), execution timing, result counts, or dataset
          snapshots. Unknown properties MUST be ignored by consumers.
        </p>
        <p>
          <!-- TODO: Enumerate recommended extension predicates and registry policy -->
        </p>
    </section>

    <section>
      <h2>Conformance</h2>
      <p>
        A <em>QVMC Server</em> conforms to this specification if it exposes a container satisfying the requirements in
        <a href="#container-model">Container model</a>, enforces media types in 
        <a href="#file-formats">File formats</a>, and maintains a valid <code>queries.ttl</code> as described in 
        <a href="#container-index">The index</a>.
      </p>
      <p>
        A <em>QVMC Client</em> conforms if it manipulates members through LDP operations and creates/patches 
        <code>queries.ttl</code> entries according to the data model.
      </p>
    </section>

    <section>
      <h2>Implementation guidance (non-normative)</h2>
      <ul>
        <li>Synchronize <code>queries.ttl</code> updates with results writes to avoid dangling references.</li>
        <li>Use ETags and conditional requests (<code>If-Match</code>) to prevent lost updates.</li>
        <li>Support both JSON and XML results to maximize interoperability.</li>
        <li>Expose <code>ldp:contains</code> in RDF representations to help crawlers discover members.</li>
      </ul>
    </section>

    <section>
      <h2>Change log (non-normative)</h2>
      <ul>
        <li>2025-09-25: Initial Editor's Draft.</li>
      </ul>
    </section>

    <section id="references"></section>
  </body>
</html>
